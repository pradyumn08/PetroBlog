<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Understanding Complex Well-Reservoir Configurations from First Principles</title>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #333;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
        }
        h1, h2, h3 {
            color: #2c3e50;
        }
        h1 {
            font-size: 2.2em;
            margin-bottom: 0.5em;
            border-bottom: 2px solid #3498db;
            padding-bottom: 10px;
        }
        h2 {
            font-size: 1.8em;
            margin-top: 1.5em;
        }
        h3 {
            font-size: 1.4em;
            margin-top: 1.2em;
        }
        p {
            margin-bottom: 1.2em;
        }
        .highlight {
            background-color: #f8f9fa;
            padding: 15px;
            border-left: 4px solid #3498db;
            margin: 20px 0;
        }
        .note {
            background-color: #e8f4f8;
            padding: 10px;
            border-radius: 5px;
            margin: 15px 0;
        }
        .analogy {
            background-color: #f0f7ee;
            padding: 15px;
            border-radius: 5px;
            margin: 15px 0;
            border-left: 4px solid #27ae60;
        }
        code {
            background-color: #f7f7f7;
            padding: 2px 4px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
        }
        .interactive-container {
            margin: 30px 0;
            padding: 20px;
            background-color: #f5f5f5;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .slider-container {
            margin: 15px 0;
        }
        canvas {
            border: 1px solid #ddd;
            margin-top: 15px;
            background-color: white;
        }
        .control-panel {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin-bottom: 15px;
        }
        .control-group {
            flex: 1;
            min-width: 200px;
        }
        button {
            background-color: #3498db;
            color: white;
            border: none;
            padding: 8px 15px;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.3s;
        }
        button:hover {
            background-color: #2980b9;
        }
        input[type="range"] {
            width: 100%;
        }
        .output-value {
            font-weight: bold;
            color: #3498db;
        }
    </style>
</head>
<body>
    <h1>Understanding Inclined Wells and Complex Well-Reservoir Configurations from First Principles</h1>
    
    <p>Welcome to a deep dive into the fascinating world of fluid flow in porous media! Today, we're going to break down complex well-reservoir configurations using first principles, specifically focusing on inclined wells and their pressure distributions. This topic might seem intimidating at first, but I promise we'll build up our understanding step by step.</p>
    
    <div class="note">
        <p><strong>Key Insight:</strong> Understanding how fluids move through porous rocks when extracted through wells at various angles is crucial for optimizing oil and gas production. The mathematics might look complex, but the underlying physics follows simple principles of fluid flow through connected pore spaces.</p>
    </div>
    
    <h2>1. The Core Problem: Pressure Distribution Around Wells</h2>
    
    <p>When we extract fluid from a reservoir using a well, we create a pressure disturbance that propagates through the porous medium. This pressure distribution depends on:</p>
    
    <ul>
        <li>The geometry of the well (vertical, horizontal, or inclined)</li>
        <li>The properties of the reservoir (permeability, porosity)</li>
        <li>The boundary conditions (closed boundaries, constant pressure, etc.)</li>
        <li>Time (transient vs. steady-state flow)</li>
    </ul>
    
    <div class="analogy">
        <h3>Real-World Analogy</h3>
        <p>Think of a reservoir as a giant sponge filled with water. When you insert a straw (well) and suck on it, you create a depression in the water level that spreads outward. The shape of this depression depends on how you orient the straw and the properties of the sponge. If you use a bent straw (inclined well), the depression pattern changes compared to a straight straw (vertical well).</p>
    </div>
    
    <h2>2. The Mathematical Foundation: Laplace-Space Point-Source Solution</h2>
    
    <p>At the heart of our analysis is the point-source solution in Laplace space. This is the mathematical representation of pressure change when fluid is extracted from an infinitesimally small point in the reservoir.</p>
    
    <p>The fundamental point-source solution in an infinite medium is given by:</p>
    
    <div class="highlight">
        <p>\[ \overline{{\Delta p}}=\frac{\overline{{\widetilde{q}}}\mu}{4\pi k L}\frac{\exp\left(-\rho_{D}\sqrt{s}\right)}{\rho_{D}} \]</p>
    </div>
    
    <p>Where:</p>
    <ul>
        <li>\(\overline{{\Delta p}}\) is the Laplace transform of pressure change</li>
        <li>\(\overline{{\widetilde{q}}}\) is the Laplace transform of flow rate</li>
        <li>\(\mu\) is fluid viscosity</li>
        <li>\(k\) is permeability</li>
        <li>\(L\) is a reference length</li>
        <li>\(\rho_D\) is dimensionless distance from the source</li>
        <li>\(s\) is the Laplace variable</li>
    </ul>
    
    <p>This equation tells us how pressure changes at any point in space due to fluid extraction at another point. It's the building block for all more complex solutions.</p>
    
    <h2>3. From Point Source to Inclined Wells</h2>
    
    <p>An inclined well can be modeled as a line of point sources. Mathematically, we integrate the point-source solution along the well trajectory:</p>
    
    <div class="highlight">
        <p>\[ \overline{{\Delta p}}=\frac{\mu}{4\pi k}\int_{-h_f/2}^{+h_f/2}\overline{{\tilde{q}}}\frac{\exp\left[-\sqrt{u}\sqrt{\tilde{r}_D^2+(z_D-\tilde{z}_{wD})^2}\right]}{\sqrt{\tilde{r}_D^2+(z_D-\tilde{z}_{wD})^2}}d\xi \]</p>
    </div>
    
    <p>Where:</p>
    <ul>
        <li>\(h_f\) is the length of the well</li>
        <li>\(\tilde{r}_D^2 = (x_D - \tilde{x}_{wD})^2 + (y_D - y_{wD})^2\)</li>
        <li>\(\tilde{x}_{wD} = x_{wD} + \xi\sin\psi\)</li>
        <li>\(\tilde{z}_{wD} = z_{wD} + \xi\cos\psi\)</li>
        <li>\(\psi\) is the inclination angle of the well</li>
    </ul>
    
    <p>This looks complicated, but it's simply adding up the pressure contributions from many point sources along the well's length, accounting for the well's angle.</p>
    
    <h3>Small-Time Approximation (Large \(s\))</h3>
    
    <p>For early times after production starts, we can use an approximation that simplifies calculations:</p>
    
    <div class="highlight">
        <p>\[ \overline{{\Delta p}}=\frac{\widetilde{q}\mu}{2\pi k h_{D}s}\left(h_{fD}\ln\frac{1}{2h_{D}\sqrt{u}}+S_{T}\right) \]</p>
    </div>
    
    <p>Where \(S_T\) is a term that accounts for the pseudoskin factor due to the well's inclination.</p>
    
    <h2>4. Interactive Visualization: Pressure Distribution Around an Inclined Well</h2>
    
    <div class="interactive-container">
        <h3>Inclined Well Pressure Distribution Simulator</h3>
        
        <div class="control-panel">
            <div class="control-group">
                <label for="angle-slider">Well Inclination Angle (ψ):</label>
                <input type="range" id="angle-slider" min="0" max="90" value="45" class="slider">
                <span id="angle-value" class="output-value">45°</span>
            </div>
            
            <div class="control-group">
                <label for="length-slider">Well Length (h<sub>f</sub>):</label>
                <input type="range" id="length-slider" min="10" max="100" value="50" class="slider">
                <span id="length-value" class="output-value">50 ft</span>
            </div>
            
            <div class="control-group">
                <label for="time-slider">Time (t<sub>D</sub>):</label>
                <input type="range" id="time-slider" min="0.01" max="10" step="0.01" value="1" class="slider">
                <span id="time-value" class="output-value">1.00</span>
            </div>
        </div>
        
        <div class="control-group">
            <button id="reset-view">Reset View</button>
            <button id="toggle-3d">Toggle 3D View</button>
        </div>
        
        <canvas id="pressure-canvas" width="750" height="400"></canvas>
        
        <p class="note">This simulation shows how pressure distributes around an inclined well in a reservoir. The colors represent pressure values (blue = low pressure, red = high pressure). Adjust the sliders to see how well inclination, length, and production time affect the pressure distribution.</p>
    </div>
    
    <h2>5. Beyond Inclined Wells: Circular Fractures and Complex Geometries</h2>
    
    <p>The same principles can be extended to more complex well configurations:</p>
    
    <h3>Circular Fractures</h3>
    
    <p>For a circular fracture parallel to the plane z=0 (like a horizontal fracture), the pressure distribution is:</p>
    
    <div class="highlight">
        <p>\[ \overline{{\mathcal{P}}}_{D}({\boldsymbol r}_{D},{\boldsymbol z}_{D},s)=\frac{2\pi}{a_{D}s} \int_{{\boldsymbol r}_{D1}}^{{\boldsymbol r}_{D2}}r_{D}^{\prime}I_{0}\left(\sqrt{\dot{\boldsymbol\pi}}{\boldsymbol r}_{D}^{\prime}\right)K_{0}\left(\sqrt{\dot{\boldsymbol\pi}}{\boldsymbol r}_{D}\right)d r_{D}^{\prime} + \text{additional terms} \]</p>
    </div>
    
    <p>Where \(I_0\) and \(K_0\) are modified Bessel functions of the first and second kind, respectively.</p>
    
    <h3>Off-Centered Wells in Cylindrical Reservoirs</h3>
    
    <p>For wells that aren't centered in cylindrical reservoirs, we use the method of images and separate the solution into parts:</p>
    
    <div class="highlight">
        <p>\[ \overline{{\Delta p}} = P + G \]</p>
    </div>
    
    <p>Where \(P\) satisfies conditions at the source and \(G\) ensures the boundary conditions are met.</p>
    
    <div class="analogy">
        <h3>Composite Reservoirs Analogy</h3>
        <p>Think of a composite reservoir as two different sponges stuck together. When you extract fluid from one side, the pressure change spreads differently through each material. The mathematical solution has to account for how these different materials interact at their boundary.</p>
    </div>
    
    <h2>6. Practical Applications and Importance</h2>
    
    <p>Understanding pressure distributions around complex well configurations has several practical applications:</p>
    
    <ul>
        <li><strong>Well Placement Optimization:</strong> Determining the best angle and location for wells to maximize production</li>
        <li><strong>Production Forecasting:</strong> Predicting how much fluid can be extracted over time</li>
        <li><strong>Interference Analysis:</strong> Understanding how multiple wells affect each other</li>
        <li><strong>Reservoir Characterization:</strong> Inferring reservoir properties from pressure data</li>
    </ul>
    
    <h2>7. Computational Challenges and Solutions</h2>
    
    <p>The equations we've discussed are mathematically complex and often require numerical methods to solve. Some key computational challenges include:</p>
    
    <ul>
        <li>Infinite series that need truncation</li>
        <li>Special functions (Bessel functions) that are computationally intensive</li>
        <li>Different formulations needed for small vs. large times</li>
    </ul>
    
    <p>Modern reservoir simulation software handles these challenges using specialized algorithms and parallel computing.</p>
    
    <h2>Conclusion: The Beauty of Mathematical Modeling</h2>
    
    <p>We've seen how starting from a simple point-source solution, we can build up to complex models of pressure distribution around inclined wells, fractures, and other configurations. This demonstrates the power of mathematical modeling in petroleum engineering.</p>
    
    <p>The ability to predict pressure behavior is crucial for efficient resource extraction and reservoir management. As computational capabilities continue to advance, our ability to model increasingly complex scenarios will only improve.</p>
    
    <div class="note">
        <p>Remember that while the mathematics may seem daunting, the underlying physical principles are straightforward: fluid flows from high pressure to low pressure through connected pore spaces, following Darcy's law. The complex equations are simply ways to capture this behavior in various geometric configurations.</p>
    </div>
    
    <script>
        // Interactive simulation code
        document.addEventListener('DOMContentLoaded', function() {
            const canvas = document.getElementById('pressure-canvas');
            const ctx = canvas.getContext('2d');
            
            // Sliders and output values
            const angleSlider = document.getElementById('angle-slider');
            const angleValue = document.getElementById('angle-value');
            const lengthSlider = document.getElementById('length-slider');
            const lengthValue = document.getElementById('length-value');
            const timeSlider = document.getElementById('time-slider');
            const timeValue = document.getElementById('time-value');
            
            // Buttons
            const resetViewBtn = document.getElementById('reset-view');
            const toggle3dBtn = document.getElementById('toggle-3d');
            
            // Initial parameters
            let wellAngle = 45; // degrees
            let wellLength = 50; // dimensionless
            let time = 1.0; // dimensionless
            let is3dView = false;
            
            // Update values from sliders
            angleSlider.addEventListener('input', function() {
                wellAngle = parseInt(this.value);
                angleValue.textContent = wellAngle + '°';
                drawPressureDistribution();
            });
            
            lengthSlider.addEventListener('input', function() {
                wellLength = parseInt(this.value);
                lengthValue.textContent = wellLength + ' ft';
                drawPressureDistribution();
            });
            
            timeSlider.addEventListener('input', function() {
                time = parseFloat(this.value);
                timeValue.textContent = time.toFixed(2);
                drawPressureDistribution();
            });
            
            resetViewBtn.addEventListener('click', function() {
                angleSlider.value = 45;
                lengthSlider.value = 50;
                timeSlider.value = 1;
                wellAngle = 45;
                wellLength = 50;
                time = 1.0;
                angleValue.textContent = '45°';
                lengthValue.textContent = '50 ft';
                timeValue.textContent = '1.00';
                drawPressureDistribution();
            });
            
            toggle3dBtn.addEventListener('click', function() {
                is3dView = !is3dView;
                drawPressureDistribution();
            });
            
            // Main drawing function
            function drawPressureDistribution() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                // Draw background grid
                drawGrid();
                
                if (is3dView) {
                    draw3DPressureDistribution();
                } else {
                    draw2DPressureDistribution();
                }
                
                // Draw well
                drawWell();
                
                // Draw legend
                drawLegend();
            }
            
            function drawGrid() {
                ctx.strokeStyle = '#ddd';
                ctx.lineWidth = 0.5;
                
                // Vertical lines
                for (let x = 0; x <= canvas.width; x += 50) {
                    ctx.beginPath();
                    ctx.moveTo(x, 0);
                    ctx.lineTo(x, canvas.height);
                    ctx.stroke();
                }
                
                // Horizontal lines
                for (let y = 0; y <= canvas.height; y += 50) {
                    ctx.beginPath();
                    ctx.moveTo(0, y);
                    ctx.lineTo(canvas.width, y);
                    ctx.stroke();
                }
            }
            
            function draw2DPressureDistribution() {
                const centerX = canvas.width / 2;
                const centerY = canvas.height / 2;
                
                // Draw pressure contours
                for (let r = 20; r <= 350; r += 20) {
                    // Calculate pressure at this radius (simplified model)
                    const pressure = calculatePressure(r);
                    
                    // Map pressure to color
                    ctx.strokeStyle = getPressureColor(pressure);
                    ctx.lineWidth = 2;
                    
                    // Draw pressure contour
                    ctx.beginPath();
                    
                    // Distort circle based on well angle
                    for (let theta = 0; theta <= 2 * Math.PI; theta += 0.1) {
                        // Calculate distortion factor based on angle
                        const angleRadians = wellAngle * Math.PI / 180;
                        const distortion = 1 + 0.5 * Math.cos(theta - angleRadians) * (1 - wellAngle / 90);
                        
                        const x = centerX + r * distortion * Math.cos(theta);
                        const y = centerY + r * distortion * Math.sin(theta);
                        
                        if (theta === 0) {
                            ctx.moveTo(x, y);
                        } else {
                            ctx.lineTo(x, y);
                        }
                    }
                    
                    ctx.closePath();
                    ctx.stroke();
                }
            }
            
            function draw3DPressureDistribution() {
                const centerX = canvas.width / 2;
                const centerY = canvas.height / 2;
                const gridSize = 10;
                
                // Draw 3D pressure surface as a grid of colored squares
                for (let x = 0; x < canvas.width; x += gridSize) {
                    for (let y = 0; y < canvas.height; y += gridSize) {
                        // Calculate distance from well center
                        const dx = x - centerX;
                        const dy = y - centerY;
                        
                        // Adjust distance based on well angle
                        const angleRadians = wellAngle * Math.PI / 180;
                        const adjustedDx = dx * Math.cos(angleRadians) + dy * Math.sin(angleRadians);
                        const adjustedDy = -dx * Math.sin(angleRadians) + dy * Math.cos(angleRadians);
                        
                        // Calculate distance to well line segment
                        const wellHalfLength = wellLength / 2;
                        const t = Math.max(-wellHalfLength, Math.min(wellHalfLength, adjustedDx));
                        const distToWell = Math.sqrt(Math.pow(adjustedDx - t, 2) + Math.pow(adjustedDy, 2));
                        
                        // Calculate pressure
                        const pressure = calculatePressureAtPoint(distToWell, t);
                        
                        // Draw colored square
                        ctx.fillStyle = getPressureColor(pressure);
                        ctx.fillRect(x, y, gridSize, gridSize);
                    }
                }
            }
            
            function drawWell() {
                const centerX = canvas.width / 2;
                const centerY = canvas.height / 2;
                const angleRadians = wellAngle * Math.PI / 180;
                const wellHalfLength = wellLength / 2;
                
                // Calculate well endpoints
                const x1 = centerX - wellHalfLength * Math.sin(angleRadians);
                const y1 = centerY - wellHalfLength * Math.cos(angleRadians);
                const x2 = centerX + wellHalfLength * Math.sin(angleRadians);
                const y2 = centerY + wellHalfLength * Math.cos(angleRadians);
                
                // Draw well
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 4;
                ctx.beginPath();
                ctx.moveTo(x1, y1);
                ctx.lineTo(x2, y2);
                ctx.stroke();
                
                // Draw well endpoints
                ctx.fillStyle = '#000';
                ctx.beginPath();
                ctx.arc(x1, y1, 5, 0, 2 * Math.PI);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(x2, y2, 5, 0, 2 * Math.PI);
                ctx.fill();
            }
            
            function drawLegend() {
                const legendWidth = 200;
                const legendHeight = 20;
                const legendX = canvas.width - legendWidth - 20;
                const legendY = 20;
                
                // Draw gradient
                const gradient = ctx.createLinearGradient(legendX, 0, legendX + legendWidth, 0);
                gradient.addColorStop(0, 'blue');
                gradient.addColorStop(0.25, 'cyan');
                gradient.addColorStop(0.5, 'green');
                gradient.addColorStop(0.75, 'yellow');
                gradient.addColorStop(1, 'red');
                
                ctx.fillStyle = gradient;
                ctx.fillRect(legendX, legendY, legendWidth, legendHeight);
                
                // Draw border
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 1;
                ctx.strokeRect(legendX, legendY, legendWidth, legendHeight);
                
                // Draw labels
                ctx.fillStyle = '#000';
                ctx.font = '12px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('Low Pressure', legendX + 50, legendY + legendHeight + 15);
                ctx.fillText('High Pressure', legendX + legendWidth - 50, legendY + legendHeight + 15);
            }
            
            function calculatePressure(r) {
                // Simplified pressure calculation based on radial distance
                // In a real model, this would use the full mathematical equations
                const s = 1 / time; // Laplace variable
                return Math.exp(-r * Math.sqrt(s) / 50) / (r / 50);
            }
            
            function calculatePressureAtPoint(r, t) {
                // More complex pressure calculation for 3D view
                // Accounts for position along well length
                const s = 1 / time;
                const wellEffect = Math.exp(-Math.abs(t) / (wellLength / 2));
                return wellEffect * Math.exp(-r * Math.sqrt(s) / 50) / (r / 50);
            }
            
            function getPressureColor(pressure) {
                // Map pressure to color
                // Normalize pressure to 0-1 range
                const normalizedPressure = Math.min(1, Math.max(0, pressure / 2));
                
                // Color gradient from blue (low pressure) to red (high pressure)
                if (normalizedPressure < 0.25) {
                    // Blue to cyan
                    const t = normalizedPressure * 4;
                    return `rgb(0, ${Math.floor(255 * t)}, 255)`;
                } else if (normalizedPressure < 0.5) {
                    // Cyan to green
                    const t = (normalizedPressure - 0.25) * 4;
                    return `rgb(0, 255, ${Math.floor(255 * (1 - t))})`;
                } else if (normalizedPressure < 0.75) {
                    // Green to yellow
                    const t = (normalizedPressure - 0.5) * 4;
                    return `rgb(${Math.floor(255 * t)}, 255, 0)`;
                } else {
                    // Yellow to red
                    const t = (normalizedPressure - 0.75) * 4;
                    return `rgb(255, ${Math.floor(255 * (1 - t))}, 0)`;
                }
            }
            
            // Initial draw
            drawPressureDistribution();
        });
    </script>
</body>
</html>