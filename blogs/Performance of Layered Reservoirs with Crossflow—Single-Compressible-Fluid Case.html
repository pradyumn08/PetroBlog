<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Understanding Layered Reservoirs with Crossflow: A First Principles Approach</title>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #333;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
        }
        h1, h2, h3 {
            color: #2c3e50;
        }
        h1 {
            border-bottom: 2px solid #3498db;
            padding-bottom: 10px;
        }
        .highlight {
            background-color: #f8f9fa;
            padding: 15px;
            border-left: 4px solid #3498db;
            margin: 20px 0;
        }
        .note {
            background-color: #e8f4f8;
            padding: 10px;
            border-radius: 4px;
            margin: 15px 0;
        }
        .simulator {
            border: 1px solid #ddd;
            padding: 20px;
            margin: 30px 0;
            border-radius: 5px;
            background-color: #f9f9f9;
        }
        .slider-container {
            margin: 15px 0;
        }
        canvas {
            border: 1px solid #ccc;
            display: block;
            margin: 20px auto;
        }
        .equation-box {
            background-color: #f5f5f5;
            padding: 10px 15px;
            border-radius: 4px;
            overflow-x: auto;
        }
        img {
            max-width: 100%;
            height: auto;
            display: block;
            margin: 20px auto;
        }
        .analogy {
            background-color: #fff8e1;
            padding: 15px;
            border-left: 4px solid #ffc107;
            margin: 20px 0;
        }
        button {
            background-color: #3498db;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }
        button:hover {
            background-color: #2980b9;
        }
    </style>
</head>
<body>
    <h1>Understanding Layered Reservoirs with Crossflow: A First Principles Approach</h1>
    
    <p>When we think about oil and gas extraction, we often imagine a simple well drawing resources from a uniform reservoir. But nature is rarely so simple. In reality, petroleum reservoirs are often layered like a stack of pancakes, with each layer having different properties. Today, we'll explore a fascinating phenomenon called "interlayer crossflow" and understand why it matters for resource extraction.</p>
    
    <div class="note">
        <strong>Key Question:</strong> How does fluid flow between layers of different permeability in an oil reservoir, and how does this affect production over time?
    </div>
    
    <h2>The Fundamental Problem</h2>
    
    <p>Imagine a cylindrical reservoir with two distinct horizontal layers stacked on top of each other. One layer (let's call it Layer 1) has low permeability—it's "tight" and doesn't let fluid flow easily. The other layer (Layer 2) has higher permeability—fluid moves through it more readily.</p>
    
    <div class="analogy">
        <strong>Everyday Analogy:</strong> Think of Layer 1 as a dense sponge that absorbs water but releases it slowly, while Layer 2 is a looser sponge that both absorbs and releases water quickly. When these sponges are stacked and you squeeze only from the edges, how does the water move between and out of them?
    </div>
    
    <p>The key insight from Russell and Prats' research is that fluid doesn't just flow horizontally toward the well—it can also flow vertically between layers. This crossflow dramatically changes how the reservoir behaves over time.</p>
    
    <h2>The Physical Model</h2>
    
    <p>Let's establish what we're working with:</p>
    
    <ul>
        <li>A cylindrical reservoir with a well at its center</li>
        <li>Two horizontal layers with different properties</li>
        <li>A single fluid of small, constant compressibility (like oil without gas)</li>
        <li>Initially uniform pressure throughout the reservoir</li>
        <li>Production at constant wellbore pressure</li>
    </ul>
    
    <p>For each layer (j = 1 or 2), we define:</p>
    <ul>
        <li>Permeability \(k_j\): how easily fluid flows through the rock</li>
        <li>Porosity \(\phi_j\): the fraction of void space in the rock</li>
        <li>Thickness \(h_j\): the height of each layer</li>
    </ul>
    
    <p>By convention, Layer 1 is always the "tight" layer where \(k_1/\phi_1 < k_2/\phi_2\).</p>
    
    <h2>The Mathematical Foundation</h2>
    
    <p>At the heart of this problem are the diffusivity equations that describe pressure changes in the reservoir. For our two layers:</p>
    
    <div class="equation-box">
        <p>Layer 1: \[\frac{1}{r_D}\frac{\partial}{\partial r_D}\left(r_D\frac{\partial P_1}{\partial r_D}\right)+\alpha_1^2\frac{\partial^2 P_1}{\partial z_{1D}^2}=\frac{\partial P_1}{\partial t_D}\]</p>
        
        <p>Layer 2: \[\frac{1}{r_D}\frac{\partial}{\partial r_D}\left(r_D\frac{\partial P_2}{\partial r_D}\right)+\alpha_2^2\frac{\partial^2 P_2}{\partial z_{2D}^2}=\beta^2\frac{\partial P_2}{\partial t_D}\]</p>
    </div>
    
    <p>Where:</p>
    <ul>
        <li>\(P_j\) is the dimensionless pressure drop in layer j</li>
        <li>\(r_D = r/r_w\) is the dimensionless radial distance (radius normalized by wellbore radius)</li>
        <li>\(z_{jD} = \pi z_j/h_j\) is the dimensionless vertical position in layer j</li>
        <li>\(t_D = \frac{k_1 t}{\phi_1 c \mu r_w^2}\) is dimensionless time</li>
        <li>\(\alpha_j = \frac{r_w}{h_j}\pi\) relates vertical and radial flow dimensions</li>
        <li>\(\beta^2 = \frac{k_1\phi_2}{k_2\phi_1}\) relates the flow properties of the two layers</li>
    </ul>
    
    <h2>Breaking Down the Solution</h2>
    
    <p>The full solution to these equations (derived in the paper using Hankel and Laplace transforms) is quite complex. However, after a short initial period, the production rate follows a simple exponential decline:</p>
    
    <div class="equation-box">
        <p>\[q = \frac{2\pi(p_i-p_w)(k_1h_1+k_2h_2)}{\mu(\ln r_{eD}-0.75)}e^{-\frac{a k_1 t}{\phi_1 c \mu r_w^2}}\]</p>
    </div>
    
    <p>Where:</p>
    <ul>
        <li>\(q\) is the production rate</li>
        <li>\(p_i\) is the initial reservoir pressure</li>
        <li>\(p_w\) is the wellbore pressure</li>
        <li>\(r_{eD} = r_e/r_w\) is the dimensionless drainage radius</li>
        <li>\(a\) is a dimensionless parameter given by:</li>
    </ul>
    
    <div class="equation-box">
        <p>\[a = \frac{2}{r_{eD}^2(\ln r_{eD}-0.75)}\left(\frac{1+\frac{k_2h_2}{k_1h_1}}{1+\frac{\phi_2h_2}{\phi_1h_1}}\right)\]</p>
    </div>
    
    <p>This formula tells us that the rate of production decline depends on the ratio of the total flow capacity \((k_1h_1+k_2h_2)\) to the total storage capacity \((\phi_1h_1+\phi_2h_2)\).</p>
    
    <h2>The Key Insight: The Equivalent Single-Layer Reservoir</h2>
    
    <p>One of the most remarkable findings is that, except for very early times, a two-layer reservoir with crossflow behaves like a single-layer reservoir with the following properties:</p>
    
    <div class="equation-box">
        <p>\[kh_{(equivalent)} = k_1h_1 + k_2h_1\]</p>
        <p>\[\phi h_{(equivalent)} = \phi_1h_1 + \phi_2h_2\]</p>
    </div>
    
    <p>This means the total flow capacity and storage capacity of the system are simply the sums of the individual layer capacities.</p>
    
    <div class="highlight">
        <p><strong>Key Takeaway:</strong> Crossflow allows the entire reservoir to act as a unified system, rather than as separate compartments. This leads to more efficient drainage of the tight layers than would otherwise be possible.</p>
    </div>
    
    <h2>Crossflow vs. No Crossflow: The Practical Difference</h2>
    
    <p>Without crossflow (a "stratified" system), each layer acts independently, and the total production rate is the sum of two separate exponential declines:</p>
    
    <div class="equation-box">
        <p>\[q_N = \frac{2\pi\Delta p(kh)_T}{(\ln r_{eD}-0.75)\mu}\left[\frac{k_1h_1}{(kh)_T}e^{-\frac{2k_1t}{(\ln r_{eD}-0.75)\phi_1c\mu r_e^2}} + \frac{k_2h_2}{(kh)_T}e^{-\frac{2k_2t}{(\ln r_{eD}-0.75)\phi_2c\mu r_e^2}}\right]\]</p>
    </div>
    
    <p>The difference is profound:</p>
    <ul>
        <li>With crossflow: The tight layer can be drained through the more permeable layer</li>
        <li>Without crossflow: Each layer depletes at its own rate, with the tight layer depleting very slowly</li>
        <li>Result: Crossflow generally leads to faster recovery and higher ultimate recovery</li>
    </ul>
    
    <h2>Interactive Reservoir Simulator</h2>
    
    <div class="simulator">
        <h3>Two-Layer Reservoir Production Simulator</h3>
        <p>Adjust the parameters below to see how a two-layer reservoir behaves with and without crossflow.</p>
        
        <div class="slider-container">
            <label for="k1">Layer 1 Permeability (k₁): <span id="k1-value">1</span> md</label><br>
            <input type="range" id="k1" min="0.1" max="5" step="0.1" value="1">
        </div>
        
        <div class="slider-container">
            <label for="k2">Layer 2 Permeability (k₂): <span id="k2-value">10</span> md</label><br>
            <input type="range" id="k2" min="5" max="50" step="1" value="10">
        </div>
        
        <div class="slider-container">
            <label for="h1">Layer 1 Thickness (h₁): <span id="h1-value">40</span> ft</label><br>
            <input type="range" id="h1" min="10" max="100" step="5" value="40">
        </div>
        
        <div class="slider-container">
            <label for="h2">Layer 2 Thickness (h₂): <span id="h2-value">20</span> ft</label><br>
            <input type="range" id="h2" min="10" max="100" step="5" value="20">
        </div>
        
        <div class="slider-container">
            <label for="phi1">Layer 1 Porosity (φ₁): <span id="phi1-value">0.08</span></label><br>
            <input type="range" id="phi1" min="0.05" max="0.2" step="0.01" value="0.08">
        </div>
        
        <div class="slider-container">
            <label for="phi2">Layer 2 Porosity (φ₂): <span id="phi2-value">0.14</span></label><br>
            <input type="range" id="phi2" min="0.05" max="0.2" step="0.01" value="0.14">
        </div>
        
        <button id="simulate-btn">Simulate Production</button>
        
        <canvas id="production-chart" width="700" height="400"></canvas>
        <div id="results"></div>
        
        <script>
            // Initialize values display
            document.getElementById('k1-value').textContent = document.getElementById('k1').value;
            document.getElementById('k2-value').textContent = document.getElementById('k2').value;
            document.getElementById('h1-value').textContent = document.getElementById('h1').value;
            document.getElementById('h2-value').textContent = document.getElementById('h2').value;
            document.getElementById('phi1-value').textContent = document.getElementById('phi1').value;
            document.getElementById('phi2-value').textContent = document.getElementById('phi2').value;
            
            // Update values display on slider change
            document.getElementById('k1').addEventListener('input', function() {
                document.getElementById('k1-value').textContent = this.value;
            });
            document.getElementById('k2').addEventListener('input', function() {
                document.getElementById('k2-value').textContent = this.value;
            });
            document.getElementById('h1').addEventListener('input', function() {
                document.getElementById('h1-value').textContent = this.value;
            });
            document.getElementById('h2').addEventListener('input', function() {
                document.getElementById('h2-value').textContent = this.value;
            });
            document.getElementById('phi1').addEventListener('input', function() {
                document.getElementById('phi1-value').textContent = this.value;
            });
            document.getElementById('phi2').addEventListener('input', function() {
                document.getElementById('phi2-value').textContent = this.value;
            });
            
            // Simulation function
            document.getElementById('simulate-btn').addEventListener('click', function() {
                // Get parameter values
                const k1 = parseFloat(document.getElementById('k1').value);
                const k2 = parseFloat(document.getElementById('k2').value);
                const h1 = parseFloat(document.getElementById('h1').value);
                const h2 = parseFloat(document.getElementById('h2').value);
                const phi1 = parseFloat(document.getElementById('phi1').value);
                const phi2 = parseFloat(document.getElementById('phi2').value);
                
                // Constants
                const mu = 1.0; // viscosity (cp)
                const c = 3e-6; // compressibility (1/psi)
                const reD = 1000; // dimensionless drainage radius
                const rw = 0.5; // wellbore radius (ft)
                const deltaP = 1000; // pressure drop (psi)
                
                // Calculate parameters
                const kh_total = k1*h1 + k2*h2;
                const phih_total = phi1*h1 + phi2*h2;
                
                // Calculate decline parameter for crossflow
                const a = (2/(reD*reD*(Math.log(reD)-0.75))) * ((1 + k2*h2/(k1*h1))/(1 + phi2*h2/(phi1*h1)));
                
                // Create time array (days)
                const maxTime = 3*365; // 3 years
                const timePoints = 500;
                const time = Array.from({length: timePoints}, (_, i) => i * maxTime / (timePoints - 1));
                
                // Calculate production rates
                const q_crossflow = time.map(t => {
                    return (2*Math.PI*deltaP*kh_total/(mu*(Math.log(reD)-0.75))) * 
                           Math.exp(-a*k1*t/(phi1*c*mu*rw*rw));
                });
                
                const q_no_crossflow = time.map(t => {
                    const term1 = (k1*h1/kh_total) * Math.exp(-2*k1*t/((Math.log(reD)-0.75)*phi1*c*mu*reD*reD));
                    const term2 = (k2*h2/kh_total) * Math.exp(-2*k2*t/((Math.log(reD)-0.75)*phi2*c*mu*reD*reD));
                    return (2*Math.PI*deltaP*kh_total/(mu*(Math.log(reD)-0.75))) * (term1 + term2);
                });
                
                // Calculate cumulative production
                let Np_crossflow = 0;
                let Np_no_crossflow = 0;
                
                const Np_crossflow_array = q_crossflow.map((q, i) => {
                    if (i === 0) {
                        Np_crossflow = 0;
                    } else {
                        const dt = (time[i] - time[i-1]);
                        Np_crossflow += 0.5 * (q + q_crossflow[i-1]) * dt;
                    }
                    return Np_crossflow;
                });
                
                const Np_no_crossflow_array = q_no_crossflow.map((q, i) => {
                    if (i === 0) {
                        Np_no_crossflow = 0;
                    } else {
                        const dt = (time[i] - time[i-1]);
                        Np_no_crossflow += 0.5 * (q + q_no_crossflow[i-1]) * dt;
                    }
                    return Np_no_crossflow;
                });
                
                // Draw the chart
                const canvas = document.getElementById('production-chart');
                const ctx = canvas.getContext('2d');
                
                // Clear canvas
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                // Set up chart dimensions
                const margin = { top: 30, right: 30, bottom: 50, left: 60 };
                const chartWidth = canvas.width - margin.left - margin.right;
                const chartHeight = canvas.height - margin.top - margin.bottom;
                
                // Find max values for scaling
                const maxRate = Math.max(...q_crossflow, ...q_no_crossflow) * 1.1;
                
                // Draw axes
                ctx.beginPath();
                ctx.moveTo(margin.left, margin.top);
                ctx.lineTo(margin.left, margin.top + chartHeight);
                ctx.lineTo(margin.left + chartWidth, margin.top + chartHeight);
                ctx.stroke();
                
                // Draw axis labels
                ctx.fillStyle = '#333';
                ctx.font = '12px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('Time (days)', margin.left + chartWidth/2, canvas.height - 10);
                
                ctx.save();
                ctx.translate(15, margin.top + chartHeight/2);
                ctx.rotate(-Math.PI/2);
                ctx.textAlign = 'center';
                ctx.fillText('Production Rate (STB/day)', 0, 0);
                ctx.restore();
                
                // Draw title
                ctx.font = '14px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('Production Rate vs Time', margin.left + chartWidth/2, 15);
                
                // Draw time axis ticks
                for (let i = 0; i <= 6; i++) {
                    const x = margin.left + (i * chartWidth / 6);
                    const timeValue = Math.round(i * maxTime / 6);
                    
                    ctx.beginPath();
                    ctx.moveTo(x, margin.top + chartHeight);
                    ctx.lineTo(x, margin.top + chartHeight + 5);
                    ctx.stroke();
                    
                    ctx.textAlign = 'center';
                    ctx.fillText(timeValue.toString(), x, margin.top + chartHeight + 20);
                }
                
                // Draw rate axis ticks
                for (let i = 0; i <= 5; i++) {
                    const y = margin.top + chartHeight - (i * chartHeight / 5);
                    const rateValue = Math.round(i * maxRate / 5);
                    
                    ctx.beginPath();
                    ctx.moveTo(margin.left, y);
                    ctx.lineTo(margin.left - 5, y);
                    ctx.stroke();
                    
                    ctx.textAlign = 'right';
                    ctx.fillText(rateValue.toString(), margin.left - 10, y + 5);
                }
                
                // Plot crossflow production
                ctx.beginPath();
                ctx.strokeStyle = '#3498db';
                ctx.lineWidth = 2;
                
                for (let i = 0; i < time.length; i++) {
                    const x = margin.left + (time[i] / maxTime) * chartWidth;
                    const y = margin.top + chartHeight - (q_crossflow[i] / maxRate) * chartHeight;
                    
                    if (i === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                }
                
                ctx.stroke();
                
                // Plot no-crossflow production
                ctx.beginPath();
                ctx.strokeStyle = '#e74c3c';
                ctx.lineWidth = 2;
                
                for (let i = 0; i < time.length; i++) {
                    const x = margin.left + (time[i] / maxTime) * chartWidth;
                    const y = margin.top + chartHeight - (q_no_crossflow[i] / maxRate) * chartHeight;
                    
                    if (i === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                }
                
                ctx.stroke();
                
                // Add legend
                ctx.font = '12px Arial';
                ctx.textAlign = 'left';
                
                ctx.fillStyle = '#3498db';
                ctx.fillRect(margin.left + 10, margin.top + 10, 15, 10);
                ctx.fillStyle = '#333';
                ctx.fillText('With Crossflow', margin.left + 30, margin.top + 18);
                
                ctx.fillStyle = '#e74c3c';
                ctx.fillRect(margin.left + 10, margin.top + 30, 15, 10);
                ctx.fillStyle = '#333';
                ctx.fillText('Without Crossflow', margin.left + 30, margin.top + 38);
                
                // Display results
                const economicRate = 50; // STB/day
                
                // Find time to economic rate
                let crossflowEconomicTime = maxTime;
                let noFlowEconomicTime = maxTime;
                
                for (let i = 0; i < time.length; i++) {
                    if (q_crossflow[i] < economicRate && crossflowEconomicTime === maxTime) {
                        crossflowEconomicTime = time[i];
                    }
                    if (q_no_crossflow[i] < economicRate && noFlowEconomicTime === maxTime) {
                        noFlowEconomicTime = time[i];
                    }
                }
                
                // Find recovery at economic limit
                let crossflowRecovery = 0;
                let noFlowRecovery = 0;
                
                for (let i = 0; i < time.length; i++) {
                    if (Math.abs(time[i] - crossflowEconomicTime) < maxTime/timePoints) {
                        crossflowRecovery = Np_crossflow_array[i];
                    }
                    if (Math.abs(time[i] - noFlowEconomicTime) < maxTime/timePoints) {
                        noFlowRecovery = Np_no_crossflow_array[i];
                    }
                }
                
                // Calculate ultimate recovery
                const OOIP = Math.PI * reD * reD * rw * rw * phih_total * c * deltaP; // Original oil in place
                const crossflowRecoveryFactor = crossflowRecovery / OOIP * 100;
                const noFlowRecoveryFactor = noFlowRecovery / OOIP * 100;
                
                // Display results
                const resultsDiv = document.getElementById('results');
                resultsDiv.innerHTML = `
                    <h4>Simulation Results:</h4>
                    <p><strong>Time to economic rate (${economicRate} STB/day):</strong><br>
                    With crossflow: ${Math.round(crossflowEconomicTime)} days<br>
                    Without crossflow: ${Math.round(noFlowEconomicTime)} days<br>
                    <strong>Time reduction: ${Math.round((noFlowEconomicTime - crossflowEconomicTime) / noFlowEconomicTime * 100)}%</strong></p>
                    
                    <p><strong>Recovery at economic limit:</strong><br>
                    With crossflow: ${Math.round(crossflowRecoveryFactor)}% of OOIP<br>
                    Without crossflow: ${Math.round(noFlowRecoveryFactor)}% of OOIP<br>
                    <strong>Recovery increase: ${Math.round(crossflowRecoveryFactor - noFlowRecoveryFactor)}%</strong></p>
                    
                    <p><strong>Conclusion:</strong> ${
                        crossflowEconomicTime < noFlowEconomicTime && crossflowRecoveryFactor > noFlowRecoveryFactor ? 
                        "Crossflow significantly improves both recovery time and total recovery." :
                        crossflowEconomicTime < noFlowEconomicTime ? 
                        "Crossflow improves recovery time but not total recovery." :
                        crossflowRecoveryFactor > noFlowRecoveryFactor ?
                        "Crossflow improves total recovery but not recovery time." :
                        "Crossflow does not provide significant benefits in this scenario."
                    }</p>
                `;
            });
        </script>
    </div>
    
    <h2>Practical Implications</h2>
    
    <p>The findings of this research have several important implications for oil and gas production:</p>
    
    <ol>
        <li><strong>Well Completion Strategy:</strong> If crossflow exists, producers can focus on perforating and treating only the more permeable layers, saving costs while still effectively draining the tight layers.</li>
        
        <li><strong>Economic Evaluation:</strong> Crossflow can significantly improve the economics of a reservoir by:
            <ul>
                <li>Reducing the time to reach economic production limits</li>
                <li>Increasing ultimate recovery from the reservoir</li>
                <li>Improving the present value of future production</li>
            </ul>
        </li>
        
        <li><strong>Reservoir Testing:</strong> By comparing observed production or pressure behavior with theoretical models, engineers can detect whether crossflow is occurring and adjust their development strategies accordingly.</li>
    </ol>
    
    <h2>Limitations and Extensions</h2>
    
    <p>The model presented has some limitations:</p>
    
    <ul>
        <li>It assumes a single fluid of small, constant compressibility (no gas phase)</li>
        <li>It doesn't account for relative permeability effects when multiple fluid phases are present</li>
        <li>It ignores gravity and capillary pressure effects</li>
        <li>It's limited to two layers, though the principles can be extended to multiple layers</li>
    </ul>
    
    <p>In real-world applications, engineers must consider these factors and potentially modify the model accordingly.</p>
    
    <h2>Conclusion</h2>
    
    <p>Interlayer crossflow is a fascinating phenomenon that significantly impacts how layered reservoirs behave during production. By understanding the physics and mathematics of this process, engineers can:</p>
    
    <ul>
        <li>Better predict reservoir performance</li>
        <li>Design more efficient completion strategies</li>
        <li>Improve economic evaluations</li>
        <li>Ultimately recover more hydrocarbons from complex reservoirs</li>
    </ul>
    
    <p>The ability of tight layers to contribute meaningfully to production through crossflow means that resources previously considered uneconomical might actually be viable. This understanding has helped the industry extract more value from existing fields and has influenced the development of new ones.</p>
    
    <div class="note">
        <p>The mathematical techniques used in this analysis, particularly the application of Hankel transforms to solve reservoir flow problems, were innovative at the time and continue to be valuable tools in reservoir engineering today.</p>
    </div>
    
</body>
</html>